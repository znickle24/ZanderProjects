package com.zandernickle.fallproject_pt1;

import android.app.Application;
import android.arch.lifecycle.LiveData;
import android.arch.persistence.room.PrimaryKey;
import android.database.sqlite.SQLiteConstraintException;
import android.os.AsyncTask;

import java.util.List;
import java.util.concurrent.ExecutionException;

import static com.zandernickle.fallproject_pt1.ReusableUtil.log;


/**
 * Contains the data operations for the {@link User} and {@link ActiveUser} database entities. Provides the appropriate
 * API for accessing {@link UserDatabase} and cloud services. Use this class to perform any operations relating to
 * persistence of User (and ActiveUser) objects.
 */
public class UserRepository {

    /**
     * Value of the {@link ActiveUser} table's only primary key. {@value #ACTIVE_USER_KEY}
     */
    private static final int ACTIVE_USER_KEY = 0;

    /**
     * Value representing a failed database operation. {@value #ABORT}
     *
     * Check for this value before assuming, for example, the database has added a new User object after calling
     * {@link #addUser(User)}.
     */
    public static final int ABORT = -1;





    public static final int NON_EXISTENT_ID = -1;

    /**
     * {@link android.arch.persistence.room.Dao} containing the dependencies of this repository's API.
     */
    private UserDao mUserDao;

    /**
     * Constructor requiring an {@link Application} base class instance in order to instantiate a single instance of
     * {@link UserDatabase} across the entire app.
     */
    UserRepository(Application application) {
        if (application == null) {
            log("APPLICATION IS NULL");
        }
        UserDatabase db = UserDatabase.getDatabase(application);
        mUserDao = db.userDao();
    }

    /**
     * Adds a new {@link User} to the database and returns the auto-generated id. If the User cannot be added to the
     * database, returns {@link #ABORT};
     *
     * Important! This method will block the calling thread.
     *
     * Also note {@link User#id} must implement the {@link PrimaryKey#autoGenerate()} annotation method to guarantee
     * the intended functionality of this method.
     *
     * @param user the User to be added to the database.
     * @return the autogenerated user id, as assigned by the database, if this call is successful. {@link #ABORT}
     * otherwise.
     */
    public int addUserSync(User user) {
        AddUserAsyncTask asyncTask = new AddUserAsyncTask(mUserDao);
        asyncTask.execute(user);
        int result;
        try {
            /* Important! The following conversion (long -> int) should be removed with significant increase in users
             * (meaning a really, really large increase in users).
             */
            result = asyncTask.get().intValue(); // Wait for the AsyncTask to return.
        } catch (Exception e) {

            /* TODO
             * asyncTask.get() throws CancellationException, ExecutionException, and InterruptedException. See the docs
             * for a detailed description of each. If one of these exceptions is thrown, may it happen after the
             * database transaction has terminated but before this method has returned the result to the caller thread?
             * If so, how should we handle the out-of-sync database?
             */
            e.printStackTrace();
            result = ABORT;
        }
        return result;
    }

    /**
     * An AsyncTask designed to create a new {@link User} in the corresponding database and return the auto-
     * generated id of that field. Thus, the {@link User#id} must implement the {@link PrimaryKey#autoGenerate()}
     * annotation method.
     *
     *
     */
    private class AddUserAsyncTask extends AsyncTask<User, Void, Long> {

        private UserDao mAsyncTaskDao;

        public AddUserAsyncTask(UserDao dao) {
            mAsyncTaskDao = dao;
        }

        @Override
        protected Long doInBackground(User... users) {
            Long result;
            try {
                result = mAsyncTaskDao.insert(users[0]);
            } catch (SQLiteConstraintException e) {
                result = Long.valueOf(ABORT);
            }
            return result;
        }
    }

//    /**
//     * Adds a new {@link ActiveUser}, a to the database if the corresponding {@link UserDatabase} table does NOT
//     * contain ANY entries. If the table does contain an entry, that entry is updated.
//     *
//     * This method wraps {@link UserDao#insert(ActiveUser)} and enforces the single row property of the ActiveUser
//     * table.  Any ActiveUser instance passed to this method will have its key set to {@link #ACTIVE_USER_KEY}. Use this
//     * property to change the primary key identifier for this row. However, doing so will add an additional row to the
//     * table.
//     *
//     * @param userId the ActiveUser object containing the values to update in the corresponding table.
//     */
    public void updateActiveUser(int id) {
        ActiveUser activeUser = new ActiveUser();
        activeUser.setRowId(ACTIVE_USER_KEY);
        activeUser.setUserId(id);
        log("UPDATING ACTIVE USER: " + activeUser.getUserId());
        new UpdateActiveUserAsyncTask(mUserDao).execute(activeUser);
    }

//    /**
//     * An AsyncTask designed to update (or create) the {@link ActiveUser#userId} stored in the corresponding
//     * {@link UserDatabase} table.
//     *
//     * In actuality, {@link #doInBackground(ActiveUser...)} calls the {@link UserDao#insert(ActiveUser)} method which
//     * is annotated with {@link android.arch.persistence.room.OnConflictStrategy#REPLACE}. Therefore, this AsyncTask
//     * will either update or create the current ActiveUser depending on the current state of the database.
//     *
//     * Important! Any method which calls {@link #doInBackground(ActiveUser...)} should guarantee the ActiveUser table
//     * has 0 or 1 rows at any given time. See {@link #update(ActiveUser)} for additional details.
//     */
    private class UpdateActiveUserAsyncTask extends AsyncTask<ActiveUser, Void, Void> {

        private UserDao mAsyncTaskDao;

        public UpdateActiveUserAsyncTask(UserDao dao) {
            mAsyncTaskDao = dao;
        }

        @Override
        protected Void doInBackground(ActiveUser... activeUsers) {
            mAsyncTaskDao.insert(activeUsers[0]);
            return null;
        }
    }

    public int getActiveUserId() {
        GetActiveUserAsyncTask asyncTask = new GetActiveUserAsyncTask(mUserDao);
        asyncTask.execute(ACTIVE_USER_KEY);
        int userId; // change to long if necessary.
        try {
            userId = asyncTask.get().getUserId(); // add this example to above docs
        } catch (Exception e) {
            e.printStackTrace();
            userId = ABORT; // This currently also includes the NullPointerException when no entries exist.
        }
        return userId;
    }

    private class GetActiveUserAsyncTask extends AsyncTask<Integer, Void, ActiveUser> {

        private UserDao mAsyncTaskDao;

        public GetActiveUserAsyncTask(UserDao dao) {
            mAsyncTaskDao = dao;
        }

        @Override
        protected ActiveUser doInBackground(Integer... integers) {
            return mUserDao.getActiveUser(integers[0]);
        }
    }

    public User getUserSync(int id) {
        GetUserAsyncTask asyncTask = new GetUserAsyncTask(mUserDao);
        asyncTask.execute(id);
        User user;
        try {
            user = asyncTask.get();
        } catch (Exception e) {
            e.printStackTrace();
            user = null;
        }
        return user;
    }

    private class GetUserAsyncTask extends AsyncTask<Integer, Void, User> {

        private UserDao mAsyncTaskDao;

        public GetUserAsyncTask(UserDao dao) {
            mAsyncTaskDao = dao;
        }

        @Override
        protected User doInBackground(Integer... integers) {
            return mAsyncTaskDao.getUserSync(integers[0]);
        }
    }

    public void updateUserAsync(User user) {
        new UpdateUserAsyncTask(mUserDao).execute(user);
    }

    private class UpdateUserAsyncTask extends AsyncTask<User, Void, Void> {

        private UserDao mAsyncTaskDao;

        public UpdateUserAsyncTask(UserDao dao) {
            mAsyncTaskDao = dao;
        }

        @Override
        protected Void doInBackground(User... users) {
            mAsyncTaskDao.updateUser(users[0]);
            return null;
        }
    }

    public LiveData<User> getUser(int id) {
        return mUserDao.getUserAsync(id);
    }











    public LiveData<Integer> getCount() {
        return mUserDao.getCount();
    }

//    public LiveData<List<User>> getAllUsers() {
////        return mUserDao.getAllUsers();
////    }



//    public long addUser(User user) {
//        new AddUserAsyncTask(mUserDao).execute(user);
//        log("THIS USER's ID: " + user.getUserId());
//        return user.getUserId();
//    }
//
//    public void addCurrentUser(ActiveUser activeUser) {
//        new AddCurrentUserAsyncTask(mUserDao).execute(activeUser);
//    }
//
//    public void updateUserFitness(User user) {
//        new UpdateUserFitnessAsyncTask(mUserDao).execute(user);
//    }
//
//    public void updateUserHealth(User user) {
//        new UpdateUserHealthAsyncTask(mUserDao).execute(user);
//    }
//
//    private class AddCurrentUserAsyncTask extends AsyncTask<ActiveUser, Void, Void> {
//
//        private UserDao mAsyncTaskDao;
//
//        AddCurrentUserAsyncTask(UserDao dao) {
//            mAsyncTaskDao = dao;
//        }
//
//        @Override
//        protected Void doInBackground(ActiveUser... activeUsers) {
//            mAsyncTaskDao.insert(activeUsers[0]);
//            return null;
//        }
//    }

//    /* TODO
//     * Return the user's id from the database (long).
//     */
//    private class AddUserAsyncTask extends AsyncTask<User, Void, Long> {
//
//        private UserDao mAsyncTaskDao;
//
//        AddUserAsyncTask(UserDao dao) {
//            mAsyncTaskDao = dao;
//        }
//
//        @Override
//        protected Long doInBackground(User... users) {
//            log("INSERTING USER " + users[0].getName());
//            Long result;
//            try {
//                result = mAsyncTaskDao.insert(users[0]);
//            } catch (SQLiteConstraintException e) {
//                return Long.valueOf(-1);
//            }
//
//            log("TEST: " + result);
//            return result;
//        }
//
//        @Override
//        protected void onPostExecute(Long aLong) {
//            super.onPostExecute(aLong);
//            mUserId = aLong;
//            log("<<<< OnPostExecute Result: " + aLong + " is this new user's ID");
//        }
//    }

//    private static class UpdateUserHealthAsyncTask extends AsyncTask<User, Void, Void> {
//
//        private UserDao mAsyncTaskDao;
//
//        UpdateUserHealthAsyncTask(UserDao dao) { mAsyncTaskDao = dao; }
//
//        @Override
//        protected Void doInBackground(User... users) {
//            log("UPDATING USER: " + users[0].getName());
//            User user = users[0];
//            mAsyncTaskDao.updateUserHealth(user.getUserId(), user.getBMI(), user.getBMR(), user.getCalorieIntake());
//            return null;
//        }
//    }
//
//    private static class UpdateUserFitnessAsyncTask extends AsyncTask<User, Void, Void> {
//
//        private UserDao mAsyncTaskDao;
//
//        UpdateUserFitnessAsyncTask(UserDao dao) { mAsyncTaskDao = dao; }
//
//        @Override
//        protected Void doInBackground(User... users) {
//            log("UPDATING USER: " + users[0].getName());
//            User user = users[0];
//            mAsyncTaskDao.updateUserFitness(user.getUserId(), user.getSex(), user.getActivityLevel(), user.getHeight(), user.getWeight(), user.getWeightGoal());
//            return null;
//        }
//    }




}

